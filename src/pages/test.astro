---
import "../styles/global.css";
import { MyCarousel } from "../components/MyCarousel.tsx";
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Basic HTML Page</title>
  </head>
  <body class="">
    <h1>Welcome to the Test Page</h1>
    <main>
      <p>
        This test page demonstrates a collection of paragraphs to help verify
        layout and text rendering. Here you will find text blocks of various
        lengths and structures, suitable for spotting spacing issues, font
        inconsistencies, or any unexpected overflow.
      </p>
      <div class="flex items-center justify-center gap-2">
        <button id="prev-btn">Previous</button>
        <ul class="flex gap-2">
          <li class="cursor-pointer">Page 1</li>
          <li class="cursor-pointer">Page 2</li>
          <li class="cursor-pointer">Page 3</li>
          <li class="cursor-pointer">Page 4</li>
          <li class="cursor-pointer">Page 5</li>
        </ul>
        <button id="next-btn">Next</button>
      </div>
      <div
        class="carousel full-bleed flex snap-x snap-mandatory gap-6 overflow-scroll"
      >
        <div class="slide">
          <img src="/screenshot-dark.png" />
        </div>
        <div class="slide">
          <img src="/screenshot-dark.png" />
        </div>
        <div class="slide">
          <img src="/screenshot-dark.png" />
        </div>
        <div class="slide">
          <img src="/screenshot-dark.png" />
        </div>
        <div class="slide">
          <img src="/screenshot-dark.png" />
        </div>
      </div>
      <p>
        Astro enables developers to quickly scaffold static and dynamic sites by
        offering a simple authoring experience and blazing fast performance.
        With its island architecture, Astro allows you to use your favorite
        JavaScript libraries only where interactive components are required,
        minimizing unnecessary resource usage.
      </p>
      <!-- <MyCarousel /> -->
      <p>
        This longer paragraph is meant to thoroughly test how extended text
        content wraps, aligns, and flows within the browser window. If there are
        any problems with the CSS rules applied to paragraphs, such as margin,
        line height, or font size, the following lines of text should reveal
        them. It's important to populate test pages with real-looking
        information, as short placeholder text can sometimes fail to surface
        layout bugs or edge cases. By examining these longer segments, you can
        be confident that actual content will display as expected once your site
        is live.
      </p>
    </main>
  </body>
</html>

<script>
  import { slide } from "astro:transitions";

  const listItems = document.querySelectorAll("ul li");
  const carousel = document.querySelector(".carousel")!;
  const slides = document.querySelectorAll(".slide");
  const prevBtn = document.getElementById("prev-btn") as HTMLButtonElement;
  const nextBtn = document.getElementById("next-btn") as HTMLButtonElement;

  let currentIndex = 0;

  // Update page indicators
  function updatePageIndicators() {
    listItems.forEach((item, index) => {
      if (index === currentIndex) {
        item.classList.add("active");
      } else {
        item.classList.remove("active");
      }
    });
  }

  // Update button states based on current index
  function updateButtonStates() {
    prevBtn.disabled = currentIndex === 0;
    nextBtn.disabled = currentIndex === slides.length - 1;
    updatePageIndicators();
  }

  // Navigate to a specific slide
  function goToSlide(index: number) {
    if (index >= 0 && index < slides.length) {
      // currentIndex = index;
      // slides[currentIndex].scrollIntoView({
      //   behavior: "smooth",
      //   block: "nearest",
      //   inline: "start",
      // });
      slides[index].scrollIntoView({
        behavior: "smooth",
        block: "nearest",
        inline: "start",
      });
      updateButtonStates();
    }
  }

  // Previous button
  prevBtn.addEventListener("click", () => {
    goToSlide(currentIndex - 1);
  });

  // Next button
  nextBtn.addEventListener("click", () => {
    goToSlide(currentIndex + 1);
  });

  // List items
  listItems.forEach((item, index) => {
    item.addEventListener("click", () => {
      goToSlide(index);
    });
  });

  // Update button states when user manually scrolls
  carousel.addEventListener("scroll", () => {
    // Find which slide is currently in view based on scroll position
    const scrollLeft = carousel.scrollLeft;
    const scrollPadding = parseFloat(
      getComputedStyle(carousel).scrollPaddingLeft,
    );

    for (let i = 0; i < slides.length; i++) {
      const htmlSlide = slides[i] as HTMLElement;
      const slideLeft = htmlSlide.offsetLeft - scrollPadding;
      const slideRight = slideLeft + htmlSlide.offsetWidth;
      if (scrollLeft >= slideLeft && scrollLeft < slideRight) {
        currentIndex = i;
        break;
      }
    }

    updateButtonStates();
  });

  // Initialize button states
  updateButtonStates();

  function testCallback(
    entries: IntersectionObserverEntry[],
    observer: IntersectionObserver,
  ) {
    entries.forEach((entry) => {
      console.log("Entry:", entry);
      if (entry.isIntersecting) {
        console.log("Slide in view:", entry.target);
      }
    });
  }

  const observer = new IntersectionObserver(testCallback, {
    root: carousel,
    // rootMargin: "0px",
    // scrollMargin: "0px",
    threshold: 1.0,
  });
  slides.forEach((slide) => observer.observe(slide));
</script>

<style>
  :root {
    --maximum-text-width: 50rem;
    --minimum-inline-margin: 1.5rem;
    --actual-inline-margin: max(
      var(--minimum-inline-margin),
      (100cqw - var(--maximum-text-width)) / 2
    );
    --actual-text-width: calc(100cqw - 2 * var(--actual-inline-margin));
    /* --minimum-slide-width: 14rem;
    --middle-column-width: min(42rem, 100%);
    --text-max-width: calc(
      var(--middle-column-width) - var(--minimum-inline-margin) * 2
    );
    --carousel-item-width-full: var(--text-max-width);
    --carousel-item-width-half: calc(
      (var(--text-max-width) - var(--minimum-inline-margin)) / 2
    );
    --carousel-item-width-third: calc(
      (var(--text-max-width) - 2 * var(--minimum-inline-margin)) / 3
    );
    --carousel-item-width: var(--carousel-item-width-half);
    --text-margin: max(calc((100vw - var(--middle-column-width)) / 2), 0px); */
  }

  html {
    container-type: inline-size;
  }

  main {
    margin-inline: var(--actual-inline-margin);
  }

  .full-bleed {
    margin-inline: calc(var(--actual-inline-margin) * -1);
  }

  /* @media screen and (width < calc(3 * 1.5rem + 2 * 14rem)) {
    :root {
      --carousel-item-width: var(--carousel-item-width-full);
    }
  } */

  .slide {
    flex: 0 0 var(--actual-text-width);
    scroll-snap-align: start;
  }
  .carousel {
    scroll-padding-left: var(--actual-inline-margin);
  }
  .carousel > :first-child,
  :last-child {
    flex-basis: calc(var(--actual-text-width) + var(--actual-inline-margin));
  }
  .carousel > :first-child {
    padding-left: var(--actual-inline-margin);
  }
  .carousel > :last-child {
    padding-right: var(--actual-inline-margin);
  }

  #prev-btn:disabled,
  #next-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  ul li.active {
    font-weight: bold;
  }
</style>
