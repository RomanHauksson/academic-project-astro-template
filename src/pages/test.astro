---
import "../styles/global.css";
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Basic HTML Page</title>
  </head>
  <body class="grid grid-cols-[1fr_min(42rem,100%)_1fr] *:col-start-2 *:px-6">
    <h1>Welcome to the Test Page</h1>
    <p>
      This test page demonstrates a collection of paragraphs to help verify
      layout and text rendering. Here you will find text blocks of various
      lengths and structures, suitable for spotting spacing issues, font
      inconsistencies, or any unexpected overflow.
    </p>
    <button id="prev-btn">Previous</button>
    <ul>
      <li>Page 1</li>
      <li>Page 2</li>
      <li>Page 3</li>
      <li>Page 4</li>
    </ul>
    <button id="next-btn">Next</button>
    <div
      class="carousel col-span-full flex snap-x snap-mandatory gap-6 overflow-scroll px-0!"
    >
      <div class="slide">
        <img src="/screenshot-dark.png" />
      </div>
      <div class="slide">
        <img src="/screenshot-dark.png" />
      </div>
      <div class="slide">
        <img src="/screenshot-dark.png" />
      </div>
      <div class="slide">
        <img src="/screenshot-dark.png" />
      </div>
      <div class="slide">
        <img src="/screenshot-dark.png" />
      </div>
    </div>
    <p>
      Astro enables developers to quickly scaffold static and dynamic sites by
      offering a simple authoring experience and blazing fast performance. With
      its island architecture, Astro allows you to use your favorite JavaScript
      libraries only where interactive components are required, minimizing
      unnecessary resource usage.
    </p>
    <p>
      This longer paragraph is meant to thoroughly test how extended text
      content wraps, aligns, and flows within the browser window. If there are
      any problems with the CSS rules applied to paragraphs, such as margin,
      line height, or font size, the following lines of text should reveal them.
      It's important to populate test pages with real-looking information, as
      short placeholder text can sometimes fail to surface layout bugs or edge
      cases. By examining these longer segments, you can be confident that
      actual content will display as expected once your site is live.
    </p>
  </body>
</html>

<script>
  const listItems = document.querySelectorAll("ul li");
  const carousel = document.querySelector(".carousel")!;
  const slides = document.querySelectorAll(".slide");
  const prevBtn = document.getElementById("prev-btn") as HTMLButtonElement;
  const nextBtn = document.getElementById("next-btn") as HTMLButtonElement;

  let currentIndex = 0;

  // Update button states based on current index
  function updateButtonStates() {
    prevBtn.disabled = currentIndex === 0;
    nextBtn.disabled = currentIndex === slides.length - 1;
  }

  // Navigate to a specific slide
  function goToSlide(index: number) {
    if (index >= 0 && index < slides.length) {
      currentIndex = index;
      slides[currentIndex].scrollIntoView({
        behavior: "smooth",
        block: "nearest",
        inline: "start",
      });
      updateButtonStates();
    }
  }

  // Previous button
  prevBtn.addEventListener("click", () => {
    goToSlide(currentIndex - 1);
  });

  // Next button
  nextBtn.addEventListener("click", () => {
    goToSlide(currentIndex + 1);
  });

  // List items
  listItems.forEach((item, index) => {
    item.addEventListener("click", () => {
      goToSlide(index);
    });
  });

  // Update button states when user manually scrolls
  carousel.addEventListener("scroll", () => {
    // Find which slide is currently in view
    const scrollLeft = carousel.scrollLeft;
    const scrollPadding = parseFloat(
      getComputedStyle(carousel).scrollPaddingLeft,
    );

    slides.forEach((slide, index) => {
      const htmlSlide = slide as HTMLElement;
      const slideLeft = htmlSlide.offsetLeft - scrollPadding;
      const slideRight = slideLeft + htmlSlide.offsetWidth;

      if (scrollLeft >= slideLeft - 10 && scrollLeft < slideRight - 10) {
        currentIndex = index;
      }
    });

    updateButtonStates();
  });

  // Initialize button states
  updateButtonStates();
</script>

<style>
  :root {
    --body-padding: 1.5rem;
    --minimum-slide-width: 14rem;
    --middle-column-width: min(42rem, 100%);
    --text-max-width: calc(
      var(--middle-column-width) - var(--body-padding) * 2
    );
    --carousel-item-width-full: var(--text-max-width);
    --carousel-item-width-half: calc(
      (var(--text-max-width) - var(--body-padding)) / 2
    );
    --carousel-item-width-third: calc(
      (var(--text-max-width) - 2 * var(--body-padding)) / 3
    );
    --carousel-item-width: var(--carousel-item-width-half);
    --text-margin: max(calc((100vw - var(--middle-column-width)) / 2), 0px);
  }

  @media screen and (width < calc(3 * 1.5rem + 2 * 14rem)) {
    :root {
      --carousel-item-width: var(--carousel-item-width-full);
    }
  }

  .slide {
    flex: 0 0 var(--carousel-item-width);
    scroll-snap-align: start;
  }
  .carousel {
    scroll-padding-left: calc(var(--text-margin) + var(--body-padding));
  }
  .carousel > :first-child,
  :last-child {
    flex-basis: calc(
      var(--text-margin) + var(--body-padding) + var(--carousel-item-width)
    );
  }
  .carousel > :first-child {
    padding-left: calc(var(--text-margin) + var(--body-padding));
  }
  .carousel > :last-child {
    padding-right: calc(var(--text-margin) + var(--body-padding));
  }

  #prev-btn:disabled,
  #next-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
</style>
